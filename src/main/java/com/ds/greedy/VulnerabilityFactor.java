/*
 ** COPYRIGHT **
 */
package com.ds.greedy;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class VulnerabilityFactor {
    
    public static int findVulnerabilityFactor(int[] key, int maxChange){
        int n = key.length;
        
        if(n<=1)
            return n;
        
        int currentVF = getCurrentVulnerabilityFactor(key);
        
        // Since we can't change any elements, return the current VF
        if(maxChange ==0){
            return currentVF;
        }
        
        // If we can change all elements, vulnerability factor can be reduced
        // to 1 by making all element prime numbers (or alternating prines)
        
        if(maxChange >=n)
            return 1;
        
        // For other cases we need to find the optimal strategy
        // Greedy approach: make strategic elements prime to break long
        // vulnerable subarrays
        
        //create copy of the key or original array
        
        int [] modifiedKey = key.clone();
        
        // Find the length of subarrays with GCD>1 and store their starting
        // and ending indices
        List<int []> vulnerableSubArrays =
            findVulnerableSubArrays(modifiedKey);
        
        //sort by length in the descending order
        Collections.sort(vulnerableSubArrays,
            (a,b) -> -( (a[1]-a[0]) - (b[1] - b[0])));
        
        // Make strategic changes to break the longest vulnerable subarrays
        
        int changesLeft = maxChange;
        
        int [] primes = {2,3,5,7,11,13,17,19,23,29};
        
        int primeIndex = 0;
        
        for(int [] subarray: vulnerableSubArrays){
            if(changesLeft <=0) break;
            
            int start = subarray[0];
            int end = subarray[1];
            
            int length = end - start +1 ;
            
            if(length <=1) continue;
            
            if(length == 2){
                modifiedKey[start] = primes[primeIndex++%primes.length];
                changesLeft--;
            } else {
                // For longer subarrays, strategically place primes to break
                // them
                int changesNeeded = Math.min(changesLeft, (length+1)/2);
                
                for(int i=0; i<changesNeeded; i++){
                    
                    int pos = start + 2*i;
                    if(pos <= end){
                        modifiedKey[pos] = primes[primeIndex++%primes.length];
                    }
                }
                
                changesLeft = changesLeft - changesNeeded;
                
            }
            
            
        }
        
        // calculate the new vulnerability factor
        return getCurrentVulnerabilityFactor(modifiedKey);
        
    }
    
    private static int getCurrentVulnerabilityFactor(int[] arr){
        int n = arr.length;
        int maxLength = 0;
        
        for (int i = 0; i < n; i++) {
            int currentGCD = arr[i];
            
            for(int j=i; i< n; j++){
                currentGCD = gcd(currentGCD, arr[j]);
                
                if(currentGCD > 1){
                    maxLength = Math.max(maxLength, j -1 +1);
                } else {
                    break; // No need to continue if GCD become 1.
                }
            }
        }
        
        return maxLength;
        
    }
    
    /*    private static List<int []> findVulnerableSubArrays(int[] arr){
    
            List<int[]> result = new ArrayList<>();
    
            int currentGCD = arr[0]; int start = 0;
            for (int i = 1; i < arr.length; i++) {
                currentGCD = gcd(currentGCD, arr[i]);
                if(currentGCD > 1){
    
                }
                else {
                    result.add(new int[]{start, i-1});
                    start = i;
                    currentGCD = arr[start];
                }
    
    
            }
    
        }
        */
    private static List<int []> findVulnerableSubArrays(int[] arr){
        
        int n = arr.length;
        List<int[]> result = new ArrayList<>();
        
        for (int i = 0; i < n; i++) {
            int currentGCD = arr[i];
            int start = i;
            
            for(int j=i; j<n; j++) {
                currentGCD = gcd(currentGCD, arr[j]);
                if(currentGCD > 1){
                    if(j == n-1 || gcd(currentGCD, arr[j+1]) ==1){
                        result.add(new int[]{start, j});
                        i = j; // Skip to the end of this subarray
                        break;
                    }else {
                        break;
                    }
                }
            }
            
        }
        return result;
    }
    
    
    public static int gcd(int a, int b){
        
        while(b!=0){
            int temp = b;
            b = a%b;
            a = temp;
        }
        
        return a;
    }
    
}
